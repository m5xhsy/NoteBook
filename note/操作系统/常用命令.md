# Linux常用命令

## 基本命令

### 文件重定向

```shell
$ command > a				# 标准输出重定向到一个文件,错误仍然输出屏幕
$ command >> a				# 标准输出重定向到一个文件(追加)
$ command 1> a				# 标准输出重定向到一个文件
$ command 2>> b				# 标准错误重定向到一个文件(追加) 
$ command 1> a 2> &1		# 标准输出和标准错误一起重定向到一个文件(1> a 2> a)
$ command >> a 2> &1		# 标准输出和标准错误一起重定向到一个文件(追加)
$ command < a > b			# 以file1做为标准输入，file2做为标准输出
$ command < a 				# 以file做为文件标准输入
```

### read 命令行交互

- 语法：`read: read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t 超时] [-u 文件描述符] [名称 ...]`

- 作用：从键盘获取字符，Shell脚本常用命令。

```shell
# 在没有指定变量时使用$REPLY获取
$ read -a arr							# 将词语赋值给arr，下标从0开始(echo ${arr[@]}查看所有词语)
$ read -d '$' text						# 持续输入直到遇到$结束而不使用换行(-d指定结束输入字符)
$ read -e text							# 在输入的时候可以使用Tab补全
$ read -n 5 text 						# 最多输入5个，可以输入分割符提前结束
$ read -N 5 text 						# 必须输入5个，忽略分割符
$ read -p "age:" text					# 输出提示且不带换行
$ read -r text							# 不允许反斜杠转义任何字符
$ read -s text							# 终端不回显任何字符(用于输入密码)
$ read -t 5 text                        # 指定等待时间，超时返回状态码则大于128。等待时间为0时只有指定文件描述符才会成功
$ read -u 3 text						# 从文件描述符中读取，3是由(exec 3<>./a.txt)命令关联的文件描述符
```

### echo 回显

- 语法：`echo: echo [-neE] [参数 ...]`
- 作用：将参数写到标准输出

```shell
$ echo -n "hello world!"	# 不输出结尾换行
$ echo -e "hello\nwoeld!"	# 启用反斜杠转义

其他用法：
$ echo "当前工作目录:`pwd`"    		# 反引号中写命令，也可以使用$(pwd)来执行
$ echo "当前登录用户:$USER"			# 输出环境变量，也可以用${USER}
$ echo "hello world!" > a.txt	 	 # 字符串重定向到a.txt中
$ echo "hello world!" >> a.txt		 # 字符串重定向到a.txt中(追加方式)

对下列反斜杠字符进行转义：
\b			# 退格
\c			# 抑制更多的输出
\e			# 转义字符
\f			# 换页字符
\n			# 换行
\r	  		# 回车
\t			# 横向制表符
\v			# 纵向制表符
\\			# 反斜杠
\0nnn		# 以 NNN（八进制）为 ASCII 码的字符。NNN 可以是 0 到 3 个八进制位
\xHH		# 以 HH（十六进制）为值的八比特字符。HH 可以是一个或两个十六进制位
\uHHHH		# 以 HHHH（十六进制）为值的 Unicode 字符。HHHH 可以是一个到四个十六进制位。
\UHHHHHHHH 	# 以 HHHHHHHH（十六进制）为值的 Unicode 字符。HHHHHHHH 可以是一到八个十六进制位。
```

### test 测试

- 语法：`test 表达式]` 或 `[ 表达式 ]`

- 作用：用于检查某个条件是否成立,它可以进行数值、字符和文件三个方面的测试

```shell
$ test -a FILE        	# 文件是否存在
$ test -b FILE        	# 文件存在且是块设备文件
$ test -c FILE        	# 文件存在并且是字符设备文件
$ test -d FILE        	# 文件存在并且是目录
$ test -e FILE        	# 文件存在
$ test -f FILE        	# 文件存在并且是正规文件
$ test -g FILE        	# 文件存在并且是设置了组ID
$ test -G FILE			# 文件存在并且属于有效组ID
$ test -h FILE        	# 文件存在并且是一个符号链接（同-L）
$ test -L FILE        	# 文件存在并且是一个符号链接（同-h）
$ test -k FILE			# 文件存在并且设置了sticky位
$ test -p FILE        	# 文件存在并且是一个命名管道
$ test -r FILE        	# 文件存在并且可读
$ test -s FILE			# 文件存在并且不为空
$ test -w FILE        	# 文件存在并且可写
$ test -x FILE        	# 文件存在并且可执行
$ test -S FILE        	# 文件存在并且是一个套接字
$ test -t FD          	# 文件描述符是在一个终端打开的
$ test -u FILE        	# 文件存在并且设置了它的set-user-id位
$ test -O FILE        	# 文件存在并且属于当前用户
$ test -N FILE			# 文件存在且自上次读取以来被修改
$ test FILE1 -nt FILE2	# 文件1比文件2更新
$ test FILE1 -ot FILE2	# 文件1比文件2更旧
$ test FILE1 -ef FILE2	# 两个文件具有同样的设备号和i结点号(硬链接和软连接)
# 注意:如果file是一个符号链接，那么除了-h和-L之外的所有文件操作符都作用于符号链接的目标，而不是符号链接本身。

整数判断
$ test a -eq b			# a和b相等
$ test a -ne b			# a不等于b
$ test a -ge b			# a大于b
$ test a -gt b			# a大于等于b
$ test a -le b 			# a小于b
$ test a -lt b			# a小于等于b

逻辑判断
$ test 1 -eq 2 -o -eq 1			# 或判断
$ test 1 -eq 2 -a 1 -eq 1		# 于判断
$ test ! 1 -eq 3 -a 1 -eq 1		# 可以写在单个条件前面
$ ! test 1 -eq 2 -a 1 -eq 1		# 也可以写在test前面，对2个条件结果取反(注意空格)

字符串判断
$ test -n "hello world!"		# 字符串长度非零
$ test -z ""					# 字符串长度为0
$ test "hello" != "world"		# 字符串不相等
$ test "hello" = "world"		# 字符串相等
```

## 用户管理

## 文件相关

## 文本处理

### tr 字符转换

- 作用：用于转换或删除文件中的字符
- 语法：`tr [选项]... SET1 [SET2]`

```shell
$ echo "abccdd" | tr a v					# 将a替换成v，输出结果为 vbccdd
$ echo "ababcf" | tr ab xy 					# a换成x，变换成y，输出为xyxycf
$ echo "aabbcc" | tr -c a z    				# 将除了a以外的字符替换成z，输出结果为aazzzzz(注意换行符也被替换)、
$ echo "aabbcc" | tr -s ab					# 压缩连在一起相同的字符a和b为一个字符，输出为abcc
$ echo "aabbcc" |tr -cs a					# 压缩处理a以外连在一起的相同字符，输出结果为aabc
$ echo "abcde" | tr -d ac					# 删除字符串中的a和c，输出为bde
$ echo "abcde" |tr -dc ac"\n"				# 删除文件中除了a，c和换行符
$ echo "aBcD12" |tr [:upper:] [:lower:]		# 字符串中大写替换成小写
$ echo "abcaebZ" |tr a-e 1-5				# a到e范围字符串对应替换为1-5，输出为123152Z


字符合集的范围：
\NNN 			# 八进制值的字符 NNN (1 to 3 为八进制值的字符)
\\ 				# 反斜杠
\a Ctrl-G \007	# 铃声   
\b Ctrl-H \010	# 退格符  
\f Ctrl-L \014	# 走行换页 
\n Ctrl-J \012	# 新行    
\r Ctrl-M \015 	# 回车 
\t Ctrl-I \011 	# tab键 
\v Ctrl-X \030 	# 水平制表符 
CHAR1-CHAR2 	# 字符范围从CHAR1到CHAR2的指定，范围的指定以ASCII 码的次序为基础，只能由小到大，不能由大到小。
[CHAR*] 		# 这是SET2专用的设定，功能是重复指定的字符到与SET1相同长度为止
[CHAR*REPEAT] 	# 这也是SET2专用的设定，功能是重复指定的字符到设定的REPEAT次数为止(REPEAT的数字采8进位制计算，以0为开始)
[:alnum:] 		# 所有字母字符与数字
[:alpha:] 		# 所有字母字符
[:blank:] 		# 所有水平空格
[:cntrl:] 		# 所有控制字符
[:digit:] 		# 所有数字
[:graph:] 		# 所有可打印的字符(不包含空格符)
[:lower:] 		# 所有小写字母
[:print:] 		# 所有可打印的字符(包含空格符)
[:punct:] 		# 所有标点字符
[:space:] 		# 所有水平与垂直空格符
[:upper:] 		# 所有大写字母
[:xdigit:] 		# 所有16进位制的数字
[=CHAR=] 		# 所有符合指定的字符(等号里的CHAR，代表你可自订的字符)
```

### sed 文件编辑

- 作用：用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等
- 语法：`sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...`

```shell
选项
 -i  	# 直接修改文件内容，不输出到终端
 -e 	# 指定动作，可以由多个-e指定多个动作
 -n		# 安静模式，只有经过sed处理的行才会被列出来
 -r		# 启用扩展正则表达式，与其他选项一起需要作为首个选项
 -f		# 读取文件中的sed动作


动作
# a插入下一行和i插入上一行
$ sed -e anewline testfile								# 每行后面都加一行
$ sed -e 2anewline testfile 							# 在第二行后面加一行"newline"
$ sed -e 2a"this is newline" testfile					# 插入带空格的文本
$ sed -e "2athis is newline" testfile					# 同上
$ sed -e "2,3a\this is newline" testfile				# 第二三行后面添加
$ sed -e "/^e/a\this is newline" testfile				# 以e开头的行后面添加新行
$ sed -e '2,$a\this is newline' testfile				# 第二行到最后一行，每行后都添加新行(双引号$符需要转义)

# c 行替换
$ sed -e '2c\xxxxx' testfile 							# 第二行替换为xxxxx
$ sed -e '2,$c\xxxxx' testfile							# 第二行到最后一行替换为xxxxxx
$ sed -e "/^e/c\xxxxx" testfile							# e开头的行替换为xxxxx
$ sed -e "/test/c\xxxxx" testfile						# 匹配到test的行替换成xxxxx
$ sed -e '/2$/cxxxxx' testfile							# 以2结尾的行替换成xxxxxx
$ sed -e '2,$cxxxxxx' testfile							# 第二行到最后一行替换成xxxxx(所有行替换成一行)
$ sed -e '/id/cxxxxx' testfile							# 包含id的行替换成xxxxx
$ sed -e '/^$/cxxxxx' testfile							# 所有空行替换为xxxxx							
$ sed -e '/id/! cxxxxx' testfile						# 不包含id的行替换成xxxxx
$ sed -e '/aaa\|bbb/cxxx' testfile 						# 将所有包含aaa和bbb的行替换成xxx(\|表示或)			

# d 行删除
$ sed -e 'd' testfile									# 删除所有的行
$ sed -e '/^$/d' testfile								# 删除所有空行
$ sed -e '2d' testfile									# 删除第2行
$ sed -e '2,5d' testfile								# 删除2到5行
$ sed -e '/[1-9]/d' testfile							# 删除包含数字1到9的行
$ sed -e '/end/d;/line/d' testfile						# 删除包含end和line的行
$ sed "/${USER}/d" testfile								# 删除包含USER环境变量的一行(双引号)
$ sed "/line/! d" testfile								# 删除不包含line的行
$ sed -e '/aaa\|bbb/d' testfile 						# 将所有包含aaa和bbb的行删除	

# s 替换
$ sed -e s/id/ID/ testfile								# 每行的第1个id替换成ID
$ sed -e s/id/ID/2	testfile							# 每行的第2个id替换成ID
$ sed -e 2s/id/ID/ testfile								# 第2行的第1个id替换成ID
$ sed -e 2s/id/ID/2 testfile							# 第2行的第2个id替换成ID
$ sed -e s/id//g testfile								# 所有的id替换成空字符串
$ sed -e 2s/id//g testfile								# 第2行的id替换成空字符串
$ sed -e 2s/id/&=/ testfile								# 第2行第一个id后添加一个等于号(&表示查找的字符串)
$ sed -e 's/^/#/' testfile								# 所有行开头添加一个#号
$ sed -e 's/^#//' testfile								# 将所有#开头的#去掉
$ sed -e '{2s/^/#/;4s/^/#/}' testfile 					# 第二行和第四行前面添加#号(中括号可以不加)
$ sed -e 's/^#this/this/' testfile						# 去掉this开头的#号
$ sed -e 's/root\|line\|this/?/g' testfile				# 将所有root,line,this替换成?
$ sed -e '/^#this/s/^#//g' testfile						# 以#this开头的行把#号去掉
$ sed -r "s/^(.*?)@(.*?)$/\2@\1/" testfile				# 将xxx@yyy替换成yyy@xxx (\1和\2表示第1个和第2个匹配的字符串)
$ sed -e 's#/etc/passwd#/etc/profile#' testfile			# 查找文本中有/，可用其他字符替换
$ sed -r 's/^( )+//' testfile							# 去掉行首的空格

# p 打印
$ sed -n 'p' testfile									# 输出所有行
$ sed -n '2p' testfile									# 输出第二行
$ sed -n '$p' testfile									# 输出最后一行
$ sed -n '5,$p' testfile 								# 输出5到最后一行
$ sed -n '5,+10p' testfile								# 输出第四行和后面的10行
$ sed -n '2p;5p;6p' testfile							# 输出第2,5,6行
$ sed -n '/id/p' testfile								# 输出宝航id的行
$ sed -n '/^#id/p' testfile								# 输出#id开头的行
$ sed -n '/?$/p' testfile								# 输出?结尾的行
$ sed -n 'p;n' testfile									# 输出奇数行
$ sed -n 'n;p' testfile 								# 输出偶数行
$ sed -n '$n' testfile									# 输出行数

文件导入导出
$ sed -e 3r\a.txt  testfile								# 将a.txt插入到testfile第三行
$ sed -e '1,3R a.txt' testfile	 						# 1到3行每行插入a.txt文件(r也可大写)
$ sed -e 1w\a.txt testfile								# 将testfile的第一行导入a.txt
$ sed -e '1,3W a.txt' testfile							# 将testfile的第1到3行导入a.txt(w也可大写)

复制粘贴
g # 覆盖
G # 追加
h # 复制一行
H # 复制一行或多行，且第一行为空
$ sed -e '1h;1d;$G' testfile							# 第1行剪切到最后
$ sed -e '1h;2,3H;1,3d;$G' testfile						# 第1到3行剪切到最后(2,3H多的第一行空行用1h填补)
$ sed -e '1h;3G' testfile								# 第1行复制到第3行
$ sed -e '1,3H;5G' testfile								# 第1到3行追加到第5行(第5到6行间插入空行加1到3行)
$ sed -e '1h;2,3H;5g' testfile							# 第1到3行覆盖到第五行
$ sed -e '5h;6g' testfile								# 第6行变成第5行(5覆盖到6上面)
```

### gerp 文本过滤

- 作用：查找文件里符合条件的字符串。
- 语法：`grep [选项]... 模式 [文件]...`

```shell
模式选择
$ grep -E "u..r" /etc/passwd 					# 使用扩展正则过滤文件(可与文件通配符一起使用，{}+|?需要转义)
$ grep -G "u..r" /etc/passwd					# 使用普通正则过滤文件
$ grep -F "u..r" /etc/passwd					# 不使用正则过滤文件(只能匹配到u..r)
$ grep -P '(?<=root).*(?=bash)' /etc/passwd		# 使用Perl正则表达式匹配
$ grep -e "user" -e "root" /etc/passwd			# 匹配Zroot或者user
$ grep -f a.txt /etc/passwd 					# 匹配a.txt文件夹中的内容
$ grep -i "USER" /etc/passwd					# 忽略大小写匹配(默认--no-ignore-case不忽略大小写)
$ grep -w "use" /etc/passwd 					# 强制完全匹配一个单词(user不会被匹配到)

杂项
$ grep -s "user" /etc/passwd123					# 不显示错误信息(etc下没有passwd123文件)
$ grep -v "user" /etc/passwd 					# 显示没匹配到的行(取反)
$ grep -V										# 显示版本信息

输出控制
$ grep -m 5 bin /etc/passwd 					# 打印匹配前5次的数据
$ grep user -b /etc/passwd						# 输出的同时打印字节偏移数
$ grep user -n /etc/passwd						# 打印行号
$ grep user --line-buffered /etc/passwd			# 每行输出后刷新输出缓冲区
$ grep user -H /etc/passwd						# 输出时打印文件名
$ grep bin -h /etc/passwd /etc/profile  		# 输出不打印文件名(过滤多个文件)
$ grep -o u..r /etc/passwd						# 只显示匹配出来的结果
$ grep -q user /etc/passwd						# 不打印匹配的结果(静默输出),可以通过echo $? 来判断是否匹配成功
$ grep -d 'read' user /etc/passwd				# 读取文件的方式(--directories=ACTION) ACTION可以为read,recurse,skip
$ grep -D 'read' user /etc/passwd				# 读取设备，队列，套接字等等(--devices=ACTION) ACTION可以为read,skip
$ grep -r user /etc/passwd 						# 等同--directories=recurse,递归匹配
$ grep -R user /etc/passwd 						# 同上，遍历所有符号链接
$ grep -L user /etc/profile /etc/passwd			# 只打印没有匹配上的文件名
$ grep -l user /etc/profile /etc/passwd			# 只打印有匹配上的文件名
$ grep -c user /etc/passwd						# 打印匹配到的行数

文件控制
$ grep -A 3 user /etc/passwd					# 匹配结果向下显示3行 (--after-context=NUM)
$ grep -B 3 user /etc/passwd 					# 匹配结果向上显示3行 (--before-context=NUM)
$ grep -C 3 user /etc/passwd					# 匹配结果上下各显示3行 (-context=NUM)
$ grep -3 3 user /etc/passwd 					# 匹配结果上下各显示3行 (效果同上)
$ grep --color=auto user /etc/passwd			# 高亮匹配(也可以是--colour=auto)
$ grep -U user /etc/passwd						# 不要清除行尾的 CR 字符（MSDOS/Windows）

补充
$ echo "<div>123123</div>" |grep "\(d.v\).*\1" # \1表示第一个括号匹配后内容在\1处匹配(第二个括号用\2匹配)加-E不需要转义
```

### cut 文本剪切

- 作用：从每个输入文件中输出指定部分到标准输出。
- 语法：`cut [选项]... [文件]...`

```shell
$ cut -b 1,5 /etc/passwd									# 以字节方式读取第一个和第五个字节
$ cut -c 1-5 /etc/passwd									# 以字符方式读取第一到五个字符
$ cut -f 1 /etc/passwd										# 以字段方式读取第一个字段
$ cut -d ":" -f 1,5 /etc/passwd								# 以冒号作为分割符号(默认TAB分割),读取第一个和第五个字段
$ cut -d ":" -f 1 -s /etc/passwd							# -s指定不打印没有分隔符的行
$ cut -d ":" -f 1 --complement /etc/passwd					# complement选项排除选中的 
$ cut -d ":" -f 1-3 --output-delimiter=" " /etc/passwd		# 输出时使用指定字符串分割
$ cut -d ":" -f 1-56 -z  /etc/passwd						# -z选项指定以NUL字符而非换行符作为行尾分隔符

范围表示:
N		# 从第1个开始数的第N个字节、字符或域
N-		# 从第N个开始到所在行结束的所有字符、字节或域
N-M		# 从第N个开始到第M个之间(包括第M个)的所有字符、字节或域
-M		# 从第1个开始到第M个之间(包括第M个)的所有字符、字节或域

补充:-n选项似乎已经弃用，-c好像也变得和-b一样了，显示中文也必须指定3个字符
```

