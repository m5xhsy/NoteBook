# 类和对象

> **C++面向对象三大特性：`封装`，`继承`,`多态`。**
>
> **C++认为`万事万物皆为对象`,对象上有其属性和行为**

## **1.封装**

### **1.1 封装的意义**

**封装意义一：**

*在设计类的时候，属性和行为写在一起，表现事务。*

*语法：`class 类名{ 访问权限: 属性/行为 };`*

*示例：*

```c++
#include <iostream>
using namespace std;

const double PI = 3.14;

class Circle {
	// 访问权限
public:  //公共权限
	// 属性  也叫成员变量、成员属性 
	int r;
	// 行为  也叫成员函数、成员方法
	double get_perimeter() {
		return 2 * PI * r;
	}
};


int main() {
	Circle c1;  // 实例化，通过类创建对象
	c1.r = 10;
	cout << "周长:" << c1.get_perimeter() << endl; // 周长:62.8
	return 0;
}
```

**封装的意义二：**

*类在设计时，可以把属性和行为放在不同的权限下，加以控制*

*权限访问有三种：`public`公共权限、`protected`保护权限、`private`私有权限*

*示例：*

```c++
#include <iostream>
using namespace std;

class Preson {
public:
	// 公有权限 类内可以访问，类外也可以访问
	int pub;
	void print_pub() {
		cout << pub << endl;
	}
private:
	// 私有权限 类内可以访问，类外不可以访问
	int pri;
	void print_pri() {
		cout << pri << endl;
	}
protected:
	// 保护权限 类内可以访问，类外不可以访问
	int pro;
	void print_pro() {
		cout << pro << endl;
	}
};

int main() {
	Preson ps;
	ps.pub = 1;
	ps.print_pub();
	ps.pri = 2;    // 错误 私有权限类外不可以访问
	ps.print_pri();// 错误 不可以访问
	ps.pro = 3;    // 错误 保护权限类外不可以访问
	ps.print_pro() // 错误 不可以访问
	return 0;
}
```

### **1.2 struct和class的区别**

在C++中，class和struct的唯一区别在于**默认访问的权限不同**，struct默认为**公共权限**，class默认为**私有权限**。

```c++
#include <iostream>
using namespace std;

class CPreson {
	string name;
	void print_name() {
		cout << name << endl;
	};
};

struct SPreson {
	string name;
	void print_name() {
		cout << name << endl;
	};
};

int main() {
	CPreson cp;
	cp.name = "张三";  // 错误，类的默认权限是私有的
	cp.print_name();   // 错误

	SPreson sp;
	sp.name = "张三";  // 正确，结构体的默认权限是公共的
	sp.print_name();   // 正确
}
```

### **1.3 成员属性设置为私有**

*优点1：将所有成员属性设置为私有，可以自己控制读写权限*

*优点2：对于写权限，我们可以检测数据的有效性*

```c++
#include <iostream>
using namespace std;

class Preson {

public:
	void setName(string name) {
		p_name = name;
	}
	string getName() {
		return p_name;
	}
	int getAge() {
		return p_age;
	}
private:
	string p_name;
	int p_age = 18;
};


int main() {
	Preson ps;
	ps.setName("张三");

	cout << "姓名:" << ps.getName() << "\t年龄:" << ps.getAge() << endl;
	return 0;
}
```

## **2.对象的初始化和清理**

### **2.1 构造函数和析构函数**

>*对象的**初始化和清理**也是两个重要的安全问题。一个对象或变量若没有初始状态，对其使用后果是未知的。同样使用完一个对象或变量，没有及时清理，也会造成一定安全问题。*
>
>*C++利用了**构造函数**和**析构函数**解决了上述问题，着这两个函数会被编译器自动调用，完成对象初始化和清理工作。*
>
>*对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们 不提供构造函函数和析构函数，编译器会为我们提供。*
>
>*编译器为我们提供的构造函数和析构函数是空实现。*

- **构造函数：**主要作用在于创建对象时为对象的成员属性赋值，构造函数由 编译器自动调用，无需手动调用
  - **语法：**`类名(){}`
  - **特点：**没有返回值也不写void；构造名称与类名相同；构造函数有参数，可以发生重载；程序在调用对象时会自动调用构造函数，且只调用一次。
- **析构函数：**主要作用在于对象销毁前系统自动调用，执行一些清理工作。
  - **语法：**`~类名(){}`
  - **特点：**没有返回值也不写void；函数名称与类名相同，且在前面加上~符号；析构函数不可以有参数，因此不可以发生重载；程序在对象销毁前自动调用析构函数，无需手动调用，而且只会调用一次。

**代码示例：***

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person() {
		cout << "构造函数输出！" << endl;
	}
	~Person() {
		cout << "析构函数输出！" << endl;
	}
	void func() {
		cout << "自定义函数输出！" << endl;
	}
};

void func() {
	Person f;  // 在栈上的数据，执行完这个函数后就会被释放，所以同时调用构造和析构；
}
int main() {
	func();

	Person p;  //先调用构造
	cout << "main函数输出！" << endl; //再输出

	system("pause"); // 确认后再main函数执行完成前调用析构函数
	return 0;
}
```

**输出结果：**

![image-20210320230707286](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210320230707286.png)

### **2.2 构造函数的分类和调用**

> **两种分类方式：**按参数分为有参构造和无参构造；按类型分为普通构造和拷贝构造。
>
> **三种调用方式：**括号法；显示法；隐式转换法。

**代码示例：**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person() {
		cout << "无参构造！  age:" << age << endl;
	}
	Person(int a) {
		age = a;
		cout << "有参构造！  age:" << age << endl;
	}
	Person(const Person& p) {
		int age = p.age;
		cout << "拷贝构造！  age:" << age << endl;
	}
	~Person() {
		cout << "析构函数！" << endl;
	}
	int age = 0;
};
```

#### **2.2.1 括号法**

```c++
int main() {
	//// 括号法
	Person pa;      // 不要写小括号，编译器会认为是函数声明
	Person pb(10);
	Person pc(pb);
    return 0;
}
```

**输出：**

![image-20210321000140193](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000140193.png)

#### **2.2.2 显示法**

```c++
int main(){
    Person();   // 当前行执行完成后系统马上回收匿名对象。
	Person(10);
	//Person(pa);   // 不要用拷贝构造函数生成匿名对象Person(pa) 相当于 Person pa，多层定义错误 
 	return 0;   
}
```

**输出：**

![image-20210321000230773](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000230773.png)

#### **2.2.3 隐式转换法**

```c++
int main(){
    Person pa = 10;
	Person pb = pa;
    return 0;
}
```

**输出：**

![image-20210321000513222](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000513222.png)

### **2.3 拷贝构造函数调用时机**

**C++中拷贝构造函数调用时机通常有三种情况：**

1.使用一个已经创建的对象来初始化一个新的对象。

2.值传递的方式给函数传值。

3.以值方式返回局部对象。

**代码示例：**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person(int a) {
		age = a;
		cout << "有参构造函数！" << endl;
	}
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	~Person() {
		cout << "析构函数调用！" << endl;
	}
	int age;
};
```

### 

#### **2.3.1 拷贝已有对象**

```c++
int main() {
	Person pa(10);

	Person pb(pa);

	return 0;
}
```

**输出：**

![image-20210321162649406](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162649406.png)

#### **2.3.2 值传递**

```c++
void doWork(Person p) {
	
}

void func() {
	Person p(10);
	doWork(p);
}
int main() {
	func();

}
```

**输出：**

![image-20210321162824173](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162824173.png)

#### **2.3.3 值返回**

```c++
Person func() {
	Person p(10);
	cout << &p << endl;
	return p;
}

int main() {
	Person p = func();
	cout << &p << endl;
}
```

**输出：**

![image-20210321162954940](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162954940.png)

### **2.4 构造函数调用规则**

默认情况下，C++编译器至少要给一个类添加三个函数：

1.默认构造函数(无参，函数体为空)

2.默认析构函数(无参，函数体为空)

3.默认拷贝构造函数，对属性进行拷贝

!>注意：如果用户有定义有参构造函数，C++不再提供默认的无参构造函数，但会提供默认的拷贝函数。如果用户定义了拷贝构造函数，C++不会再提供其他构造函数。

```c++
#include <iostream>
using namespace std;

class PersonA {
public:
	PersonA(int a) {
		cout << "有参构造函数！" << endl;
	}
};

class PersonB {
public:
	PersonB(const PersonB& p) {
		cout << "拷贝构造函数！" << endl;
	}
};
int main() {
	PersonA pa;  // 错误，c++不提供默认构造函数
	PersonB pb;  // 错误，c++不提供其他构造函数
}
```

**5.深拷贝和浅拷贝**

**浅拷贝：**简单的赋值操作；

**深拷贝：**在堆区重新申请空间，进行拷贝操作。

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person(string name,int age) {
		p_name = name;
		p_age = new int(age);
		cout << "有参构造函数！" << endl;
	}

	~Person() {
		delete p_age;   //错误，触发一个断点
		cout << "析构函数调用！" << endl;
	}

	string p_name;
	int* p_age;
};



int main() {
	Person pa("屁屁", 18);
	cout << "姓名：" << pa.p_name << "  年龄：" << *pa.p_age << endl;

	Person pb(pa);
	cout << "姓名：" << pb.p_name << "  年龄：" << *pb.p_age << endl;
	return 0;
}
```

**输出：**![image-20210321234916717](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321234916717.png)

!>编译器自带的拷贝构造函数是浅拷贝，直接拷贝的m_age的内存地址。而析构函数的执行顺序是先入后出的，所以先执行pb的析构函数，而m_age已经被pb释放，pa再次释放就报错。

**解决办法：**在类中自定义一个拷贝构造函数，将p_age进行深拷贝，重新在堆区申请一个内存空间。

```c++
Person(const Person& p) {
    p_name = p.p_name;
    p_age = new int(*p.p_age);
}
```

**输出：**

![image-20210321235523668](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321235523668.png)

### **2.5 初始化列表**

C++提供初始化列表的语法，用来初始化属性。

**语法：**`构造函数():属性1(值1),属性2(值2)...{}`或者`构造函数(类型1 变量1,类型2 变量2...):属性1(变量1),属性2(变量2)...{}`

```c++
#include <iostream>
using namespace std;

class Person {
public:
	// 普通初始化
	Person(int a, int b, int c) {
		m_a = a;
		m_b = b;
		m_c = c;
	}
	// 初始化列表
	Person(int a, int b, int c, int d) :m_a(a), m_b(b), m_c(c), m_d(d) {}
	
	int m_a;
	int m_b;
	int m_c;
	int m_d;
};


int main() {
	Person pa(1, 2, 3);
	cout << pa.m_a << pa.m_b << pa.m_c << endl; // 123
	Person pb(1, 2, 3, 4);
	cout << pb.m_a << pb.m_b << pb.m_c << pb.m_d << endl;  //1234
	return 0;
}
```

### **2.6 类对象作为类成员**

C++中的类成员可以是另一个类的对象，我们称该类成员成为`对象成员`。即B类中有对象A作为成员，则A为对象成员。

```c++
#include <iostream>
using namespace std;

class Phone {
public:
	Phone(string n,string ver, int pri):name(n),version(ver),price(pri) {
		cout << "Phone 构造！" << endl;
	}
	~Phone() {
		cout << "Phone 析构！" << endl;
	}
	string name;
	string version;
	int price;
};

class Person {
public:
	Person(string per_n, string pho_n, string ver, int pic):name(per_n),po(pho_n, ver, pic) {
		cout << "Person 构造！" << endl;
	}
	~Person() {
		cout << "Person 析构！" << endl;
	}
	string name;
	Phone po;
};


int main() {
	Person per("屁屁", "华为", "HarmonyOS1.0", 3999);
	cout << "姓名：" << per.name << "  手机：" << per.po.name
		<< "  版本：" << per.po.version << "  价格：" << per.po.price << endl;
	return 0;
}
```

**输出：**

![image-20210322012522878](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210322012522878.png)



### **2.7 静态成员**

静态成员变量就是在成员变量和成员函数前加上关键字`static`，称为静态成员。

**静态成员分成：**

- 静态成员变量
  - 所有对象共享一份数据；
  - 在编译阶段分配内存；
  - 类内声明，类外初始化。
- 静态成员函数
  - 所有对象共享一个函数；
  - 静态成员函数只能访问静态成员变量；
  - 静态成员函数可以由类对象或者类名调用;
  - 语法：`对象.静态成员函数()`或`类名::静态成员函数()`。

**代码示例：**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	static void  func() {
		A = 10;	  // 正确，可以修改静态成员变量
		//B = 10; // 错误，不能修改非静态成员变量
		cout << "静态成员函数调用！" << endl;
	};
	static int A;  // 静态成员变量
	int B;		   // 非静态成员变量
};
int Person::A = 0;  // 静态成员变量需要类外初始化

int main() {
	// 通过对象调用
	Person p;
	p.func();

	// 通过类名调用
	Person::func();
	return 0;
}
```

!>注意：静态成员函数也有权限控制，非公共权限不可类外调用。



## **3.C++对象模型和this指针**

### **3.1 成员变量和成员函数的存储** 

在C++中，类内成员变量和成员函数分开储存，只有非静态成员变量才在类的对象上。

```c++
#include <iostream>
using namespace std;

class PersonA {

};
class PersonB {
	int a;
};

class PersonC {
	static int a;
};
int PersonC::a;

class PersonD {
	void func() {}
};

class PersonE {
	static void func() {}
};
int main() {
	PersonA pa;
	cout << " 空对象：" << sizeof(pa) << endl;
	PersonB pb;
	cout << " 非静态成员变量：" << sizeof(pb) << endl;
	PersonC pc;
	cout << " 静态成员变量：" << sizeof(pc) << endl;
	PersonD pd;
	cout << " 非静态成员函数：" << sizeof(pd) << endl;
	PersonE pe;
	cout << " 静态成员函数：" << sizeof(pe) << endl;
	return 0;
}
```

**输出结果：**

![image-20210322171857191](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210322171857191.png)

### **3.2 this指针概念**

**我们知道在C++中成员和成员函数是分开储存的，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分哪个对象调用的自己呢？**

**C++提供特殊的对象指针，this指针解决上述问题。this指向被调用的成员函数所属的对象。**

- this指针是一个隐含 每一个非静态成员函数内的一种指针。

- this指针不需要定义，直接可以使用。

**this指针的用途：**

- 当形参和成员变量同名时，可以用this指针来区分；
- 在类的非静态成员函数中返回对象本身，可以使用`return *this`

```c++
#include <iostream>
using namespace std;

class Person {
public:
	string name;
	int age;
	Person(string name, int age) {
		this->name = name;
		this->age = age;
	}
	Person ageAdd1(int num) {  //这里会重新复制一个类
		this->age += num;
		return *this;
 	}
	Person& ageAdd2(int num) {  // 返回引用
		this->age += num;
		return *this;
	}
};

int main() {
	Person pa("屁屁",18);
	pa.ageAdd1(10).ageAdd1(5).ageAdd1(5); // 28 重新复制的，所以输出是28
	cout << pa.age << endl;
	pa.ageAdd2(10).ageAdd2(5).ageAdd2(5); // 48 返回的是引用，所以值是48
	cout << pa.age << endl;
	return 0;
}
```

!>**参考拷贝[函数调用时机的值返回](note/c++/c++核心编程/类和对象?id=_233-值返回)**，如果返回的是类对象，则会重新复制一个类，如果返回类型是引用，就可以链式调用。

### **3.3 空指针访问成员函数**

C++中空指针也可以调用成员函数，但是也要注意函数内部有没有用到this指针

```c++
#include <iostream>
using namespace std;


class Person {
public:
	void showClassName() {
		cout << "this is Person Class " << endl;
	}
	void showPersonAge() {
		// 这里引发异常，因为p指向的是NULL，访问权限冲突。解决方法可以加一个this==NULL的判断
		cout << "年龄：" << age << endl;  // 这里的age相当于this->age， 
	}
	static int b;
	int age;
};
int Person::b = 10;

int main() {
	Person* p = NULL;
	p->showClassName();    // 空指针可以调用成员函数，但是成员函数中用到了this指针就不可以
	//p->showPersonAge();   // 错误，p指向的是NULL，不可访问 
	cout << p->age << endl;  //错误
	cout << p->b << endl;   // 正确，b是静态成员变量
	return 0;
}
```

!>注意：在[成员变量和成员函数的储存](note/c++/c++核心编程/类和对象?id=_31-成员变量和成员函数的存储)中我们可以知道，非静态成员变量和类对象储存在一起，当类对象指向NULL时，就不可以用this访问非静态成员变量。且this只能用于非静态成员函数内部。

### **3.4 const修饰成员函数**

**常函数：**

- 成员函数加上const后我们称为**常函数**；
- 常函数不可以修改成员属性；
- 成员属性声明时加关键字`mutable`后，常函数中依然可以修改。

**常对象：**

- 声明对象前加const称该对象为**常对象**；
- 常对象只能调用常函数。

```c++
#include <iostream>
using namespace std;


class Person {
public:
	// this指针的本质是指针常量，指针的指向是不可以修改的。相当于Person* const this
	void change1() {
		this->a = 100;
	}
	// 如果在成员函数后加上const就相当于this指针被修饰成 const Person* const this
	void change2() const {
		//this->a = 100;  // 错误，不可以修改
		this->b = 100;  // 正确，加上mutable修饰的变量在常函数中也可以修改
	}
	int a;
	mutable int b;
};


int main() {
	const Person p;  // 在对象前加cons变成常对象
	// p.change1();   // 错误，常对象只能调用常函数,因为普通函数可以修改成员属性
	p.change2();	// 
	return 0;
}
```

## **4.友元**

在程序中，有些私有 属性也想让类外特殊的一些函数或类镜进行访问，就需要用到**友元**。友元的目的就是让一个函数或类访问另外一个类中的私有成员。

**友元的三种实现：**

- 全局函数做友元`friend 返回值类型 函数名();`
- 类做友元`friend class 类名`
- 成员函数做友元`friend 返回值类型 作用域::成员函数()`

### **4.1 全局函数做友元**

```c++
#include <iostream>
using namespace std;

class Building {
	friend void friendFunc(Building* building); // 在类中声明
public:
	Building(string dr,string br):drawingRoom(dr),bedRoom(br) {}
	string drawingRoom;  // 客厅
private:
	string bedRoom;  // 卧室
};


void friendFunc(Building *building) {
	cout << "访问：" << building->drawingRoom << endl;
	cout << "访问：" << building->bedRoom << endl;  //如果不声明友元函数，这里会报错
}

int main() {
	Building b("客厅","卧室");
	friendFunc(&b);
	return 0;
}
```

### **4.2 类做友元**

```c++
#include <iostream>
using namespace std;


class Building {
public:
	friend class FriendClass;  // 声明友元对象
	Building(string dr, string br) :drawingRoom(dr), bedRoom(br) {}
	string drawingRoom;
private:
	string bedRoom;
};

class FriendClass {
public:
	FriendClass(Building* building):bd(building) {};
	void func() {
		cout << "访问：" << this->bd->drawingRoom << endl;
		cout << "访问：" << this->bd->bedRoom << endl;
	}
private:
	Building* bd;
};


int main() {
	Building b("客厅", "卧室");
	FriendClass fc(&b);
	fc.func();
	return 0;
}
```

### **4.3 成员函数做友元**

```c++
#include <iostream>
using namespace std;

class Building;  // 提前声明

class FriendClass {
public:
	FriendClass();
	void func1();
	void func2();
	Building* bd;

};

class Building {
public:
	friend void FriendClass::func1();  // 设置func1可以访问
	Building();
	string drawingRoom;
private:
	string bedRoom;
};

Building::Building() {
	this->drawingRoom = "客厅";
	this->bedRoom = "卧室";
}

void FriendClass::func2() {
	cout << "f2访问：" << bd->drawingRoom << endl;
	cout << "f2访问：" <<bd->bedRoom << endl;
}

void FriendClass::func1() {
	cout << "f1访问：" << bd->drawingRoom << endl;
	cout << "f1访问：" << bd->bedRoom << endl; // 会报错
}

FriendClass::FriendClass() {
	this->bd = new Building;
}

int main() {
	FriendClass f1;
	f1.func1();
	f1.func2();  // 报错：没有声明友元
}
```



