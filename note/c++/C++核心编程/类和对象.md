# 类和对象

> **C++面向对象三大特性：`封装`，`继承`,`多态`。**
>
> **C++认为`万事万物皆为对象`,对象上有其属性和行为**

## **1.封装**

### **1.1 封装的意义**

**封装意义一：**

*在设计类的时候，属性和行为写在一起，表现事务。*

*语法：`class 类名{ 访问权限: 属性/行为 };`*

*示例：*

```c++
#include <iostream>
using namespace std;

const double PI = 3.14;

class Circle {
	// 访问权限
public:  //公共权限
	// 属性  也叫成员变量、成员属性 
	int r;
	// 行为  也叫成员函数、成员方法
	double get_perimeter() {
		return 2 * PI * r;
	}
};


int main() {
	Circle c1;  // 实例化，通过类创建对象
	c1.r = 10;
	cout << "周长:" << c1.get_perimeter() << endl; // 周长:62.8
	return 0;
}
```

**封装的意义二：**

*类在设计时，可以把属性和行为放在不同的权限下，加以控制*

*权限访问有三种：`public`公共权限、`protected`保护权限、`private`私有权限*

*示例：*

```c++
#include <iostream>
using namespace std;

class Preson {
public:
	// 公有权限 类内可以访问，类外也可以访问
	int pub;
	void print_pub() {
		cout << pub << endl;
	}
private:
	// 私有权限 类内可以访问，类外不可以访问
	int pri;
	void print_pri() {
		cout << pri << endl;
	}
protected:
	// 保护权限 类内可以访问，类外不可以访问
	int pro;
	void print_pro() {
		cout << pro << endl;
	}
};

int main() {
	Preson ps;
	ps.pub = 1;
	ps.print_pub();
	ps.pri = 2;    // 错误 私有权限类外不可以访问
	ps.print_pri();// 错误 不可以访问
	ps.pro = 3;    // 错误 保护权限类外不可以访问
	ps.print_pro() // 错误 不可以访问
	return 0;
}
```

### **1.2 struct和class的区别**

在C++中，class和struct的唯一区别在于**默认访问的权限不同**，struct默认为**公共权限**，class默认为**私有权限**。

```c++
#include <iostream>
using namespace std;

class CPreson {
	string name;
	void print_name() {
		cout << name << endl;
	};
};

struct SPreson {
	string name;
	void print_name() {
		cout << name << endl;
	};
};

int main() {
	CPreson cp;
	cp.name = "张三";  // 错误，类的默认权限是私有的
	cp.print_name();   // 错误

	SPreson sp;
	sp.name = "张三";  // 正确，结构体的默认权限是公共的
	sp.print_name();   // 正确
}
```

### **1.3 成员属性设置为私有**

*优点1：将所有成员属性设置为私有，可以自己控制读写权限*

*优点2：对于写权限，我们可以检测数据的有效性*

```c++
#include <iostream>
using namespace std;

class Preson {

public:
	void setName(string name) {
		p_name = name;
	}
	string getName() {
		return p_name;
	}
	int getAge() {
		return p_age;
	}
private:
	string p_name;
	int p_age = 18;
};


int main() {
	Preson ps;
	ps.setName("张三");

	cout << "姓名:" << ps.getName() << "\t年龄:" << ps.getAge() << endl;
	return 0;
}
```

## **2.对象的初始化和清理**

### **2.1 构造函数和析构函数**

>*对象的**初始化和清理**也是两个重要的安全问题。一个对象或变量若没有初始状态，对其使用后果是未知的。同样使用完一个对象或变量，没有及时清理，也会造成一定安全问题。*
>
>*C++利用了**构造函数**和**析构函数**解决了上述问题，着这两个函数会被编译器自动调用，完成对象初始化和清理工作。*
>
>*对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们 不提供构造函函数和析构函数，编译器会为我们提供。*
>
>*编译器为我们提供的构造函数和析构函数是空实现。*

- **构造函数：**主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
  - **语法：**`类名(){}`
  - **特点：**没有返回值也不写void；构造名称与类名相同；构造函数有参数，可以发生重载；程序在调用对象时会自动调用构造函数，且只调用一次。
- **析构函数：**主要作用在于对象销毁前系统自动调用，执行一些清理工作。
  - **语法：**`~类名(){}`
  - **特点：**没有返回值也不写void；函数名称与类名相同，且在前面加上~符号；析构函数不可以有参数，因此不可以发生重载；程序在对象销毁前自动调用析构函数，无需手动调用，而且只会调用一次。

**代码示例：***

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person() {
		cout << "构造函数输出！" << endl;
	}
	~Person() {
		cout << "析构函数输出！" << endl;
	}
	void func() {
		cout << "自定义函数输出！" << endl;
	}
};

void func() {
	Person f;  // 在栈上的数据，执行完这个函数后就会被释放，所以同时调用构造和析构；
}
int main() {
	func();

	Person p;  //先调用构造
	cout << "main函数输出！" << endl; //再输出

	system("pause"); // 确认后再main函数执行完成前调用析构函数
	return 0;
}
```

**输出结果：**

![image-20210320230707286](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210320230707286.png)

### **2.2 构造函数的分类和调用**

> **两种分类方式：**按参数分为有参构造和无参构造；按类型分为普通构造和拷贝构造。
>
> **三种调用方式：**括号法；显示法；隐式转换法。

**代码示例：**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person() {
		cout << "无参构造！  age:" << age << endl;
	}
	Person(int a) {
		age = a;
		cout << "有参构造！  age:" << age << endl;
	}
	Person(const Person& p) {
		int age = p.age;
		cout << "拷贝构造！  age:" << age << endl;
	}
	~Person() {
		cout << "析构函数！" << endl;
	}
	int age = 0;
};
```

#### **2.2.1 括号法**

```c++
int main() {
	//// 括号法
	Person pa;      // 不要写小括号，编译器会认为是函数声明
	Person pb(10);
	Person pc(pb);
    return 0;
}
```

**输出：**

![image-20210321000140193](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000140193.png)

#### **2.2.2 显示法**

```c++
int main(){
    Person();   // 当前行执行完成后系统马上回收匿名对象。
	Person(10);
	//Person(pa);   // 不要用拷贝构造函数生成匿名对象Person(pa) 相当于 Person pa，多层定义错误 
 	return 0;   
}
```

**输出：**

![image-20210321000230773](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000230773.png)

#### **2.2.3 隐式转换法**

```c++
int main(){
    Person pa = 10;
	Person pb = pa;
    return 0;
}
```

**输出：**

![image-20210321000513222](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321000513222.png)

### **2.3 拷贝构造函数调用时机**

**C++中拷贝构造函数调用时机通常有三种情况：**

1.使用一个已经创建的对象来初始化一个新的对象。

2.值传递的方式给函数传值。

3.以值方式返回局部对象。

**代码示例：**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person(int a) {
		age = a;
		cout << "有参构造函数！" << endl;
	}
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	~Person() {
		cout << "析构函数调用！" << endl;
	}
	int age;
};
```

### 

#### **2.3.1 拷贝已有对象**

```c++
int main() {
	Person pa(10);

	Person pb(pa);

	return 0;
}
```

**输出：**

![image-20210321162649406](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162649406.png)

#### **2.3.2 值传递**

```c++
void doWork(Person p) {
	
}

void func() {
	Person p(10);
	doWork(p);
}
int main() {
	func();

}
```

**输出：**

![image-20210321162824173](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162824173.png)

#### **2.3.3 值返回**

```c++
Person func() {
	Person p(10);
	cout << &p << endl;
	return p;
}

int main() {
	Person p = func();
	cout << &p << endl;
}
```

**输出：**

![image-20210321162954940](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321162954940.png)

### **2.4 构造函数调用规则**

默认情况下，C++编译器至少要给一个类添加三个函数：

1.默认构造函数(无参，函数体为空)

2.默认析构函数(无参，函数体为空)

3.默认拷贝构造函数，对属性进行拷贝

!>注意：如果用户有定义有参构造函数，C++不再提供默认的无参构造函数，但会提供默认的拷贝函数。如果用户定义了拷贝构造函数，C++不会再提供其他构造函数。

```c++
#include <iostream>
using namespace std;

class PersonA {
public:
	PersonA(int a) {
		cout << "有参构造函数！" << endl;
	}
};

class PersonB {
public:
	PersonB(const PersonB& p) {
		cout << "拷贝构造函数！" << endl;
	}
};
int main() {
	PersonA pa;  // 错误，c++不提供默认构造函数
	PersonB pb;  // 错误，c++不提供其他构造函数
}
```

**5.深拷贝和浅拷贝**

**浅拷贝：**简单的赋值操作；

**深拷贝：**在堆区重新申请空间，进行拷贝操作。

```c++
#include <iostream>
using namespace std;

class Person {
public:
	Person(string name,int age) {
		p_name = name;
		p_age = new int(age);
		cout << "有参构造函数！" << endl;
	}

	~Person() {
		delete p_age;   //错误，触发一个断点
		cout << "析构函数调用！" << endl;
	}

	string p_name;
	int* p_age;
};



int main() {
	Person pa("屁屁", 18);
	cout << "姓名：" << pa.p_name << "  年龄：" << *pa.p_age << endl;

	Person pb(pa);
	cout << "姓名：" << pb.p_name << "  年龄：" << *pb.p_age << endl;
	return 0;
}
```

**输出：**![image-20210321234916717](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321234916717.png)

!>编译器自带的拷贝构造函数是浅拷贝，直接拷贝的m_age的内存地址。而析构函数的执行顺序是先入后出的，所以先执行pb的析构函数，而m_age已经被pb释放，pa再次释放就报错。

**解决办法：**在类中自定义一个拷贝构造函数，将p_age进行深拷贝，重新在堆区申请一个内存空间。

```c++
Person(const Person& p) {
    p_name = p.p_name;
    p_age = new int(*p.p_age);
}
```

**输出：**

![image-20210321235523668](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210321235523668.png)

### **2.5 初始化列表**

C++提供初始化列表的语法，用来初始化属性。

**语法：**`构造函数():属性1(值1),属性2(值2)...{}`或者`构造函数(类型1 变量1,类型2 变量2...):属性1(变量1),属性2(变量2)...{}`

```c++
#include <iostream>
using namespace std;

class Person {
public:
	// 普通初始化
	Person(int a, int b, int c) {
		m_a = a;
		m_b = b;
		m_c = c;
	}
	// 初始化列表
	Person(int a, int b, int c, int d) :m_a(a), m_b(b), m_c(c), m_d(d) {}
	
	int m_a;
	int m_b;
	int m_c;
	int m_d;
};


int main() {
	Person pa(1, 2, 3);
	cout << pa.m_a << pa.m_b << pa.m_c << endl; // 123
	Person pb(1, 2, 3, 4);
	cout << pb.m_a << pb.m_b << pb.m_c << pb.m_d << endl;  //1234
	return 0;
}
```

### **2.6 类对象作为类成员**

C++中的类成员可以是另一个类的对象，我们称该类成员成为`对象成员`。即B类中有对象A作为成员，则A为对象成员。

```c++
#include <iostream>
using namespace std;

class Phone {
public:
	Phone(string n,string ver, int pri):name(n),version(ver),price(pri) {
		cout << "Phone 构造！" << endl;
	}
	~Phone() {
		cout << "Phone 析构！" << endl;
	}
	string name;
	string version;
	int price;
};

class Person {
public:
	Person(string per_n, string pho_n, string ver, int pic):name(per_n),po(pho_n, ver, pic) {
		cout << "Person 构造！" << endl;
	}
	~Person() {
		cout << "Person 析构！" << endl;
	}
	string name;
	Phone po;
};


int main() {
	Person per("屁屁", "华为", "HarmonyOS1.0", 3999);
	cout << "姓名：" << per.name << "  手机：" << per.po.name
		<< "  版本：" << per.po.version << "  价格：" << per.po.price << endl;
	return 0;
}
```

**输出：**

![image-20210322012522878](https://gitee.com/m5xhsy/picture-bed/raw/master/images/image-20210322012522878.png)



### **2.7 静态成员**