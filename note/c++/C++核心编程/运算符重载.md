# 运算符重载



**运算符重载概念：对已有的运算符重新进行定义，赋予另外一种功能，以适用不同数据类型。**

## **1.加号运算符重载**

**作用：**实现两个自定义数据类型相加的运算；

```c++
#include <iostream>
using namespace std;

class Number {
public:
	Number() {};
	Number(int a,int b) {
		this->a = a;
		this->b = b;
	}
	Number operator+(Number& n) {
		Number temp;
		temp.a = a + n.a;
		temp.b = b + n.b;
		return temp;
	}
public:
	int a;
	int b;
};

Number operator+(Number& n1, int n) {
	Number temp;
	temp.a = n1.a + n;
	temp.b = n1.b + n;
	return temp;
}

// 可以发生函数重载
//Number operator+(Number& n1,Number& n2) {
//	Number temp;
//	temp.a = n1.a + n2.a;
//	temp.b = n1.b + n2.b;
//	return temp;
//}

int main() {
	Number na(5, 10);
	Number nb(1, 2);

	Number nc = na.operator+(nb);// 成员函数运算符重载
	cout << "a:" << nc.a << "\tb:" << nc.b << endl;

	Number nd = na + nb;		// 成员函数运算符重载
	cout << "a:" << nd.a <<  "\tb:" << nd.b << endl;

	Number ne = operator+(na, 5); // 全局函数运算符重载
	cout << "a:" << ne.a << "\tb:" << ne.b << endl;

	Number nf = na + 5;  // 全局函数运算符重载
	cout << "a:" << nf.a << "\tb:" << nf.b << endl;
	return 0;
}
```

!>注意：对于内置的数据类型的表达式的运算符是不可能改变的，且不要滥用运算符重载。

## **2.左移运算符重载**

重载左移运算符配合友元可以实现输出自定义数据类型

```c++
#include <iostream>
using namespace std;

class Number {
public:
	friend ostream& operator<<(ostream& cout, Number n);
	Number(int a, int b, int c) :m_a(a), m_b(b), m_c(c) {};
	void operator<<(ostream& cout) {  
		// cout属于ostream数据类类型，只能存在一个，传入得用引用的方式
		cout << "a=" << m_a << "  b=" << m_b << "  c=" << m_c << endl;
	}
private:
	int m_a;
	int m_b;
	int m_c;
};

ostream& operator<<(ostream& cout,Number n) {
	cout << "a=" << n.m_a << "  b=" << n.m_b << "  c=" << n.m_c;
	return cout;  // 利用链式编程（返回cout追加endl）
}

int main() {
	Number na(10, 20, 30);
	na.operator<<(cout);   //成员函数运算符重载(一般不使用成员函数运算符重载)
	na << cout;            // 成员函数运算符重载简写

	operator<<(cout, na) << endl;    // 全局函数运算符重载
	cout << na << " 链式" <<endl;    // 全局函数运算符重载简写 
	return 0;
}

```

!>cout属于`ostream`数据类型，且只能存在一个，所以函数用传cout只能用引用的方式。左移运算符的重载一般使用全局函数的形式重载。