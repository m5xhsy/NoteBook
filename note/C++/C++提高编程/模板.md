# 模板

## **1.模板的概念**

模板就是建立**通用的模具**，大大**提高复用性**

模板的特点：

* 模板不可以直接使用，它只是一个框架
* 模板的通用并不是万能的

## **2.函数模板**

- C++另外一种编程思想称为`泛型编程`，主要利用的技术就是模板

- C++提供两种模板机制`函数模板`和`类模板`

### **2.1 函数模板语法**

**函数模板的作用：**建立一个通用函数，其返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表

**语法：**`template <typename T>`

- template 声明创建模板
- typenam 表明其后面的符号是一种数据类型，可以用class代替

- T 通用数据类型，名称可替换，一般为大写字母

**代码示例：**

```c++
#include <iostream>
using namespace std;

template<typename T>  //利用模板提供通用的交换函数
void myswap(T &a, T &b) {
	T temp = a;
	a = b;
	b = temp;
}


int main() {
	int a = 1;
	int b = 0;

	// 1.自动类型推导
	myswap(a, b);
	cout << "a=" << a << "  b=" << b << endl;

	// 2.显示指定类型
	myswap<int>(a, b);
	cout << "a=" << a << "  b=" << b << endl;
	return 0;
}
```

### **2.2 函数模板注意事项**

- 自动类型推导必须推导出一致的数据类型
- 模板必须要确定出T的数据类型

```c++
#include <iostream>
using namespace std;


template <typename T>
void swap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

template <typename T>
void func() {
	cout << "func" << endl;
}


int main() {
	int a = 10;
	char b = 'a';
	// swap(a,b);  // 自动推导必须是一致的数据类型

	// func(); // 模板必须指定T的数据类型，应该改为func<int>();
	return 0;
}
```

### **2.3 模板案例**

```c++
#include <iostream>
using namespace std;

template <typename T>
void myswap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}


template <typename T>
void mysort(T arr[], int len) {
	for (int i = 0; i < len; i++) {
		int max = i;
		for (int j = i + 1; j < len; j++) {
			if (arr[j] > arr[max]) {
				max = j;
			}
			
		}
		if (max != i) {
			myswap(arr[i], arr[max]);
		}
	}

	for (int i = 0; i < len; i++) {
		cout << arr[i] << " ";

	}
	cout << endl;
}


int main() {
	int arr1[5] = { 5,8,1,5,6 };
	mysort(arr1,5);
	
	char arr2[5] = { 'e','a','f','d','b' };
	mysort(arr2, 5);

	return 0;
}
```

### **2.4 普通函数与函数模板的区别**

**普通函数与函数模板区别：**

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换

**示例：**

```c++
#include <iostream>
using namespace std;

int myAdd1(int a, int b) {
	return a + b;
}

template <typename T>
T myAdd2(T a, T b) {
	return a + b;
}

int main() {
	int a = 0;
	char b = 'a';

	cout << myAdd1(a, b) << endl;
	//cout << myAdd2(a, b) << endl; // 报错，自动推导不可以发生隐式类型转换
	cout << myAdd2<int>(a, b) << endl;
	return 0;
}
```

### **2.5 模板函数的调用**

调用规则如下：

- 如果函数模板和普通函数都可以实现，优先调用普通函数
- 可以通过空模板参数列表来强制调用函数模板
- 函数模板也可以发生重载
- 如果函数模板可以产生更好的匹配,优先调用函数模板

```c++
#include <iostream>
using namespace std;

void print(int a) {
	cout << "普通函数调用！" << endl;
}

template<typename T>
void print(T a) {
	cout << "模板函数调用！" << endl;
}

template<typename T>
void print(T a,T b) {
	cout << "模板函数调用！" << endl;
}

int main() { 
	int a = 10;
	print(a);  //普通函数调用
	print<>(a);  //模板函数调用
	print<int>(a); // 模板函数调用
	print(a,a);  //模板函数调用
	return 0;
}
```

### **2.6 模板的局限性**

模板的通用性并不是万能的，比如自定义类型就无法使用普通的模板，因此C++为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**

```c++
#include <iostream>
using namespace std;

class Person {
public:
	string name;
	int age;
};

//普通函数模板
template <typename T>
bool func(T& a, T& b) {
	if (a == b) {
		return true;
	}
	return false;
}

//具体化，显示具体化的原型和定意思以template<>开头，并通过名称来指出类型
//具体化优先于常规模板
template<> bool func(Person& a, Person& b) {
	if (a.age == b.age and a.name == b.name) {
		return true;
	}
	return false;
}


int main() {
	int a = 10;
	int b = 20;

	cout << func(a, b) << endl;

	//自定义数据类型，不会调用普通的函数模板
	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
	Person pa = { "张三",18 };
	Person pb = { "李四",18 };
	cout << func(pa, pb) << endl;
	return 0;
}
```

## **3.类模板**

### **3.1 类模板语法**

**类模板作用：**建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。

**语法：**`**template <typename T>`

- template   声明创建模板

- typename  表面其后面的符号是一种数据类型，可以用class代替

- T  通用的数据类型，名称可以替换，通常为大写字母

**代码示例：**

```c++
#include <string>
//类模板
template<class NameType, class AgeType> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

void test01()
{
	// 指定NameType 为string类型，AgeType 为 int类型
	Person<string, int>P1("孙悟空", 999);
	P1.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

!> 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板

### **3.2 类模板与函数模板的区别**

类模板与函数模板区别主要有两点：

- 类模板没有自动类型推导的使用方式
- 类模板在模板参数列表中可以有默认类型

```c++
#include <iostream>
using namespace std;

template <class N, class A = int>
class Person {
public:
	N m_name;
	A m_age;
public:
	Person(N name, A age) {
		this->m_name = name;
		this->m_age = age;
	}
};


int main() {
	//Person("屁屁", 18); // 不支持自动推导
	Person<string, int> p1("屁屁", 18);
	Person<string> p2("屁屁", 18);  // 在模板的参数列表中可以有默认数据类型
	return 0;
}
```

### **3.3 类模板中成员函数创建时机**

类模板中成员函数和普通类中成员函数创建时机是有区别的：

* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建

!> 在下列代码中如果MyClass只是普通类，编译的时候会报错，因为funcA和funcB中obj调用的是2个类中的函数，而obj只能是一个类的实例化。并且main函数中代码如果全注释或只注释C部分，代码编译不会出错，因为类模板中的成员函数是在调用的时候才创建。

```c++
#include <iostream>
using namespace std;

class PersonA {
public:
	void person_a() {
		cout << "PersonA" << endl;
	}
};

class PersonB {
public:
	void person_b() {
		cout << "PersonB" << endl;
	}
};

template<class T>
class MyClass {
public:
	T obj;
	void  funcA() {
		obj.person_a();
	}
	void funcB() {
		obj.person_b();
	}
};

int main() {
	// A 这部分代码编译和运行不会出错
	MyClass<PersonA> ma;
	ma.funcA();

	// B 这部分代码编译和运行不会出错
	MyClass<PersonB> mb;
	mb.funcB();

	// C 这部分代码不嫩通过编译
	MyClass<PersonA> mc;
	mc.funcA();
	mc.funcB();

	return 0;
}
```

### **3.4 类模板对象做函数参数**

类模板实例化出的对象向函数传参，一共有三种方式：

- 指定传入类型：直接使用对象的数据类型
- 参数模板化：将对象中的参数变为模板进行传递
- 整个类模板化：将这个对象 类型进行模板化传递

```c++
#include <iostream>
using namespace std;

template <class N, class A>
class Person {
public:
	Person(N name, A age) {
		this->name = name;
		this->age = age;
	}
	string name;
	int age;

	void showInfo() {
		cout << "name:" << name << "  age:" << age << endl;
	}
};

// 1.指定传入类型(常用)
void print_info_a(Person<string, int>& p) {
	p.showInfo();
}
// 2.参数模板化
template<class N, class A>
void print_info_b(Person<N, A>& p) {
	p.showInfo();
}

// 3.整个类模板化
template<typename T>
void print_info_c(T p) {
	p.showInfo();
}

int main() {
	Person<string, int> p("屁屁", 18);

	print_info_a(p);
	print_info_b(p);
	print_info_c(p);

	return 0;
}
```



### **3.5 类模板与继承**

当类模板碰到继承时，需要注意一下几点：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板

```c++
#include <iostream>
using namespace std;

template <class T>
class Base {
public:
	T m;
};

// 子类继承时候指定父类的模板
class SonA :public Base<int> {
public:
	SonA(int a) {
		this->m = a;
	}
};

// 子类的模板指定父类的模板
template <class F>
class SonB :public Base<F> {
public:
	SonB(F a) {
		this->m = a;
		cout << typeid(this->m).name() << endl;
	}
};
int main() {
	SonA sa(2);
	SonB<int> sb(2);
	return 0;
}
```

